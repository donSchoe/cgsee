#include <glm/glm.hpp>

#include <vector>
#include <unordered_map>
#include <functional>

#include "vertexreuse.h"

namespace {

struct VertexData
{
    VertexData(glm::vec3& vertex, glm::vec3& normal, glm::vec2& texCoord) :
        vertex(vertex), normal(normal), texCoord(texCoord)
    { }
    glm::vec3 vertex;
    glm::vec3 normal;
    glm::vec2 texCoord;
};


bool operator==(const VertexData& vL, const VertexData& vR)
{
    return (vL.vertex == vR.vertex)
        && (vL.normal == vR.normal)
        && (vL.texCoord == vR.texCoord);
}

template<class T> class VertexHash;

template<>
class VertexHash<VertexData> {
public:
    static const size_t numHashElements = 8;

    size_t operator()(const VertexData& v) const 
    {
        size_t hashValues[numHashElements] = {
            std::hash<float>()(v.vertex[0]),
            std::hash<float>()(v.vertex[1]),
            std::hash<float>()(v.vertex[2]),
            std::hash<float>()(v.normal[0]),
            std::hash<float>()(v.normal[1]),
            std::hash<float>()(v.normal[2]),
            std::hash<float>()(v.texCoord[0]),
            std::hash<float>()(v.texCoord[1])};
        size_t resultHash = 0;
        for (int i = 0; i < numHashElements; ++i)
            resultHash ^= (hashValues[i] << i);
        return resultHash;
    }
};

}

typedef std::pair<VertexData, int> VertexPair;
typedef std::unordered_map<VertexData, int, VertexHash<VertexData>> VertexMap;

void VertexReuse::reuseVertices(t_vec3s& vertices, t_vec3s& normals, t_vec2s& texcs, t_uints& indices)
{
    const size_t numVertices = vertices.size();

    bool normalsUsed = true;
    bool texcsUsed = true;
    // fill all unused input vectors with 0 values.
    if (normals.size() < numVertices) {
        normals.resize(numVertices);
        normalsUsed = false;
    }
    if (texcs.size() < numVertices) {
        texcs.resize(numVertices);
        texcsUsed = false;
    }

    std::vector<VertexData> vertexData;
    vertexData.reserve(numVertices);
    size_t vertexDataLastIndex = 0;
    std::vector<int> indexMapping;
    indexMapping.reserve(numVertices);
    VertexMap vertexMap;
    for (uint i = 0; i < numVertices; ++i)
    {
        // fill map with vertex data
        VertexData vd(vertices[i], normals[i], texcs[i]);
        
        std::pair<VertexMap::iterator,bool> pair = vertexMap.insert(VertexPair(vd, vertexDataLastIndex));

        indexMapping.push_back(pair.first->second);
        if (pair.second) {
            vertexData.push_back(vd);
            ++vertexDataLastIndex;
        }
    }
    const size_t vertexDataSize = vertexData.size();

    // build output arrays with optimized data
    // clean up arrays that are not used
    vertices.resize(vertexDataSize);
    for (uint i = 0; i < vertexDataSize; ++i) {
        vertices[i] = vertexData[i].vertex;
    }

    if (normalsUsed) {
        normals.resize(vertexDataSize);
        for (uint i = 0; i < vertexDataSize; ++i) {
            normals[i] = vertexData[i].normal;
        }
    }
    else
        normals.clear();

    if (texcsUsed) {
        texcs.resize(vertexDataSize);
        for (uint i = 0; i < vertexDataSize; ++i) {
            texcs[i] = vertexData[i].texCoord;
        }
    }
    else
        texcs.clear();
    
    // return indices generated by the map
    const size_t numIndices = indices.size();
    for (uint i = 0; i < numIndices; ++i)
    {
        indices[i] = indexMapping[indices[i]];
    }
}
