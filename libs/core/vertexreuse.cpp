#include <glm/glm.hpp>

#include <vector>
#include <unordered_map>
#include <functional>

#include "vertexreuse.h"

namespace {

struct VertexData
{
    VertexData(glm::vec3& vertex, glm::vec3& normal, glm::vec3& texCoord) :
        vertex(vertex), normal(normal), texCoord(texCoord)
    { }
    glm::vec3 vertex;
    glm::vec3 normal;
    glm::vec3 texCoord;
};

template<class T> class VertexHash;

template<>
class VertexHash<VertexData> {
public:
    size_t operator()(const VertexData &v) const 
    {
        size_t hashValues[] = {
            std::hash<float>()(v.vertex[0]),
            std::hash<float>()(v.vertex[1]),
            std::hash<float>()(v.vertex[2]),
            std::hash<float>()(v.normal[0]),
            std::hash<float>()(v.normal[1]),
            std::hash<float>()(v.normal[2]),
            std::hash<float>()(v.texCoord[0]),
            std::hash<float>()(v.texCoord[1]),
            std::hash<float>()(v.texCoord[2]) };
        size_t resultHash = 0;
        for (int i = 0; i < sizeof(hashValues)/sizeof(hashValues[0]); ++i)
            resultHash ^= (hashValues[i] << i);
        return resultHash;
    }
};

}

void VertexReuse::reuseVertices(t_vec3s& vertices, t_vec3s& normals, t_vec2s& texcs, t_uints& indices)
{
    std::vector<VertexData> vertexData;
    vertexData.reserve(vertices.size());
    std::unordered_map<VertexData, int, VertexHash<VertexData>> vertexMap;
    for (int i = 0; i < vertices.size(); ++i)
    {
        // fill map with vertex data
        // build arrays
        // return indices generated by the map
    }
}
